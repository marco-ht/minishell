/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   wildcards.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mpierant & sfelici <marvin@student.42ro    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/17 16:07:48 by mpierant &        #+#    #+#             */
/*   Updated: 2025/07/17 20:13:56 by mpierant &       ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

int	expand_wildcards(t_execcmd *ecmd)
{
	char			*old_argv[MAX_ARGS];
	char			old_q[MAX_ARGS];
	int				old_alloc[MAX_ARGS];
	int				argc;
	int				i;
	int				j;
	int				t_count;
	char			*pat;
	char			*slash;
	int				dir_len;
	char			*dir_pat;
	char			*file_pat;
	DIR				*d1;
	struct dirent	*e1;
	struct stat		st;
	DIR				*d2;
	struct dirent	*e2;
	int				found;
	char			*matches[MAX_ARGS];
	int				match_count;
	char			*tmp_path;
	char			*tmp;

	argc = 0;
	while (ecmd->argv[argc] && argc < MAX_ARGS)
		argc++;
	i = 0;
	while (i < argc)
	{
		old_argv[i] = ecmd->argv[i];
		old_q[i] = ecmd->qtype[i];
		old_alloc[i] = ecmd->allocated[i];
		i++;
	}
	i = 0;
	t_count = 0;
	while (i < argc && t_count < MAX_ARGS - 1)
	{
		pat = old_argv[i];
		if (old_q[i] != 'a')
		{
			ecmd->argv[t_count] = old_argv[i];
			ecmd->qtype[t_count] = old_q[i];
			ecmd->allocated[t_count] = old_alloc[i];
			t_count++;
			i++;
			continue ;
		}
		if (strncmp(pat, "./", 2) == 0 && ft_strchr(pat, '*'))
		{
			found = handle_dot_slash_pattern(pat, ecmd, &t_count);
			if (found == 0)
			{
				ecmd->argv[t_count] = old_argv[i];
				ecmd->qtype[t_count] = old_q[i];
				ecmd->allocated[t_count] = old_alloc[i];
				t_count++;
			}
			i++;
			continue ;
		}
		if (pat[0] == '.' && ft_strchr(pat, '*'))
		{
			found = handle_hidden_files(pat, ecmd, &t_count);
			if (found == 0)
			{
				ecmd->argv[t_count] = old_argv[i];
				ecmd->qtype[t_count] = old_q[i];
				ecmd->allocated[t_count] = old_alloc[i];
				t_count++;
			}
			i++;
			continue ;
		}
		slash = ft_strchr(pat, '/');
		if (slash)
		{
			found = 0;
			match_count = 0;
			dir_len = slash - pat;
			dir_pat = ft_strndup(pat, dir_len);
			file_pat = ft_strdup(slash + 1);
			d1 = opendir(".");
			if (d1)
			{
				while ((e1 = readdir(d1)))
				{
					if (e1->d_name[0] == '.')
						continue ;
					if (match_star(dir_pat, e1->d_name))
					{
						if (stat(e1->d_name, &st) == 0 && S_ISDIR(st.st_mode))
						{
							d2 = opendir(e1->d_name);
							if (d2)
							{
								while ((e2 = readdir(d2)))
								{
									if (e2->d_name[0] == '.')
										continue ;
									if (match_star(file_pat, e2->d_name))
									{
										tmp = ft_strjoin(e1->d_name, "/");
										tmp_path = ft_strjoin(tmp, e2->d_name);
										free(tmp);
										matches[match_count] = tmp_path;
										match_count++;
										found = 1;
									}
								}
								closedir(d2);
							}
						}
					}
				}
				closedir(d1);
			}
			if (match_count > 0)
			{
				sort_matches(matches, match_count);
				i = 0;
				while (i < match_count && t_count < MAX_ARGS - 1)
				{
					ecmd->argv[t_count] = matches[i];
					ecmd->qtype[t_count] = 'a';
					ecmd->allocated[t_count] = 1;
					t_count++;
					i++;
				}
			}
			free(dir_pat);
			free(file_pat);
			if (found == 0)
			{
				ecmd->argv[t_count] = old_argv[i];
				ecmd->qtype[t_count] = old_q[i];
				ecmd->allocated[t_count] = old_alloc[i];
				t_count++;
			}
			i++;
			continue ;
		}
		if (ft_strchr(pat, '*'))
		{
			found = 0;
			match_count = 0;
			d1 = opendir(".");
			if (d1)
			{
				while ((e1 = readdir(d1)))
				{
					if (e1->d_name[0] == '.')
						continue ;
					if (match_star(pat, e1->d_name))
					{
						matches[match_count] = ft_strdup(e1->d_name);
						match_count++;
						found = 1;
					}
				}
				closedir(d1);
			}
			if (match_count > 0)
			{
				sort_matches(matches, match_count);
				j = 0;
				while (j < match_count && t_count < MAX_ARGS - 1)
				{
					ecmd->argv[t_count] = matches[j];
					ecmd->qtype[t_count] = 'a';
					ecmd->allocated[t_count] = 1;
					t_count++;
					++j;
				}
			}
			if (found == 0)
			{
				ecmd->argv[t_count] = old_argv[i];
				ecmd->qtype[t_count] = old_q[i];
				ecmd->allocated[t_count] = old_alloc[i];
				t_count++;
			}
			i++;
			continue ;
		}
		ecmd->argv[t_count] = old_argv[i];
		ecmd->qtype[t_count] = old_q[i];
		ecmd->allocated[t_count] = old_alloc[i];
		t_count++;
		i++;
	}
	ecmd->argv[t_count] = NULL;
	ecmd->qtype[t_count] = '\0';
	ecmd->allocated[t_count] = 0;
	t_count++;
	while (t_count < MAX_ARGS)
	{
		ecmd->argv[t_count] = NULL;
		ecmd->qtype[t_count] = '\0';
		ecmd->allocated[t_count] = 0;
		t_count++;
	}
	return (0);
}
